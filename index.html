<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ğŸ¦‰ Seelaz Games</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700;900&display=swap');

    :root {
      --bg:      #1C0D00;
      --surface: #2E1600;
      --cb:      #5C3010;
      --rim:     #8B4E1A;
      --accent:  #E8843E;
      --gold:    #F4A840;
      --cream:   #FDF0DC;
      --dark:    #2C1204;
      --shadow:  rgba(0,0,0,.55);
      --easy:    #4caf50;
      --med:     #F4A840;
      --hard:    #e53935;
    }

    *, *::before, *::after { box-sizing:border-box; margin:0; padding:0; }

    body {
      min-height: 100vh;
      background: radial-gradient(ellipse at 50% 0%, #3B1800 0%, var(--bg) 70%);
      font-family: 'Cairo', sans-serif;
      color: var(--cream);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px 10px 40px;
      overflow-x: hidden;
    }

    @keyframes floatOwl     { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-12px)} }
    @keyframes fadeUp       { from{opacity:0;transform:translateY(30px)} to{opacity:1;transform:translateY(0)} }
    @keyframes fadeIn       { from{opacity:0} to{opacity:1} }
    @keyframes popIn        { 0%{opacity:0;transform:scale(.6)} 70%{transform:scale(1.08)} 100%{opacity:1;transform:scale(1)} }
    @keyframes spinGlow     { 0%{box-shadow:0 0 0 4px rgba(244,168,64,0)} 50%{box-shadow:0 0 22px 6px rgba(244,168,64,.65)} 100%{box-shadow:0 0 0 4px rgba(244,168,64,0)} }
    @keyframes pulse        { 0%,100%{transform:scale(1)} 50%{transform:scale(1.04)} }
    @keyframes shake        { 0%,100%{transform:rotateY(180deg) translateX(0)} 25%{transform:rotateY(180deg) translateX(-6px)} 75%{transform:rotateY(180deg) translateX(6px)} }
    @keyframes confettiFall { 0%{transform:translateY(-20px) rotate(0deg);opacity:1} 100%{transform:translateY(110vh) rotate(720deg);opacity:0} }
    @keyframes starPop      { 0%{transform:scale(0) rotate(-20deg);opacity:0} 60%{transform:scale(1.3) rotate(5deg);opacity:1} 100%{transform:scale(1) rotate(0deg);opacity:1} }
    @keyframes previewPulse { 0%,100%{box-shadow:0 0 0 0 rgba(244,168,64,0)} 50%{box-shadow:0 0 20px 5px rgba(244,168,64,.45)} }
    @keyframes borderGlow   { 0%,100%{border-color:var(--gold)} 50%{border-color:var(--accent)} }

    /* â•â• OVERLAY SCREENS â•â• */
    .screen-overlay {
      position: fixed; inset: 0; z-index: 200;
      background: radial-gradient(ellipse at 50% 0%, #3B1800 0%, var(--bg) 70%);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      padding: 24px; overflow-y: auto;
      transition: opacity .4s ease;
    }
    .screen-overlay.fade-out { opacity: 0; pointer-events: none; }
    .screen-overlay.hidden   { display: none !important; }

    /* â•â• HOME SCREEN â•â• */
    .home-logo    { font-size:80px; animation:floatOwl 3s ease-in-out infinite, popIn .7s ease both; filter:drop-shadow(0 0 24px rgba(244,168,64,.75)); }
    .home-brand   { font-size:clamp(1.6rem,5vw,2.6rem); font-weight:900; color:var(--gold); text-shadow:0 2px 16px rgba(244,168,64,.5); animation:fadeUp .6s .15s ease both; }
    .home-brand span { color:var(--accent); }
    .home-tagline { font-size:.9rem; color:#c9a070; margin-top:4px; margin-bottom:36px; animation:fadeUp .6s .3s ease both; text-align:center; }

    .game-cards { display:flex; gap:20px; justify-content:center; flex-wrap:wrap; width:100%; max-width:560px; animation:fadeUp .6s .45s ease both; }

    .game-card {
      flex:1; min-width:190px; max-width:240px;
      background:var(--surface); border:2px solid var(--rim);
      border-radius:24px; padding:28px 16px; cursor:pointer; text-align:center;
      transition:transform .22s, border-color .22s, box-shadow .22s;
    }
    .game-card:hover { transform:translateY(-6px); border-color:var(--gold); box-shadow:0 12px 32px rgba(244,168,64,.25); }
    .game-card.active { border-color:var(--gold); background:linear-gradient(145deg,#4A2500,#3A1800); box-shadow:0 0 24px rgba(244,168,64,.4); }
    .game-card .gc-icon    { font-size:54px; line-height:1; margin-bottom:10px; display:block; }
    .game-card .gc-name    { font-size:1.1rem; font-weight:900; color:var(--gold); }
    .game-card .gc-desc    { font-size:.72rem; color:#c9a070; margin-top:8px; line-height:1.55; }

    .home-play-btn {
      margin-top:20px;
      background:linear-gradient(135deg,var(--accent),#c96020);
      border:none; color:#fff; font-family:'Cairo',sans-serif;
      font-size:1.1rem; font-weight:900; padding:15px 56px;
      border-radius:50px; cursor:pointer;
      box-shadow:0 4px 22px rgba(232,132,62,.5);
      transition:transform .15s, box-shadow .15s;
      display:none;
    }
    .home-play-btn.show { display:inline-block; animation:pulse 2s ease-in-out infinite; }
    .home-play-btn:hover  { transform:translateY(-3px); box-shadow:0 8px 28px rgba(232,132,62,.6); }
    .home-play-btn:active { transform:translateY(0); }

    /* â•â• HOME INLINE SETTINGS â•â• */
    #home-settings {
      display:none; width:100%; max-width:500px;
      background:linear-gradient(145deg,#321400,#1e0b00);
      border:1.5px solid var(--rim); border-radius:22px;
      padding:22px 20px 20px; margin-top:18px;
      animation:fadeUp .4s ease both;
    }
    #home-settings.show { display:block; }
    #home-settings .section-label { margin-bottom:8px; }
    #home-settings .choice-row { margin-bottom:18px; }
    #home-settings .choice-row:last-of-type { margin-bottom:0; }

    /* â•â• SHARED SETTINGS â•â• */
    .section-label { font-size:.72rem; letter-spacing:2px; text-transform:uppercase; color:#c9a070; margin-bottom:10px; width:100%; text-align:center; }
    .choice-row    { display:flex; gap:14px; justify-content:center; flex-wrap:wrap; margin-bottom:28px; width:100%; max-width:500px; }

    /* â•â• MEMORY GAME SCREEN â•â• */

    .lang-btn {
      flex:1; min-width:90px; max-width:145px;
      background:var(--surface); border:2px solid var(--rim);
      border-radius:18px; padding:15px 10px; cursor:pointer; text-align:center;
      transition:transform .2s, border-color .2s, background .2s;
      animation:fadeUp .6s .45s ease both;
    }
    .lang-btn .l-flag { font-size:28px; }
    .lang-btn .l-name { display:block; font-size:.88rem; font-weight:700; color:var(--cream); margin-top:5px; }
    .lang-btn .l-sub  { display:block; font-size:.7rem; color:#c9a070; }
    .lang-btn:hover   { transform:translateY(-3px); border-color:var(--gold); }
    .lang-btn.active  { border-color:var(--gold); background:linear-gradient(145deg,#4A2500,#3A1800); box-shadow:0 0 18px rgba(244,168,64,.35); animation:previewPulse 2s ease infinite, borderGlow 2s ease infinite; }

    .diff-btn {
      flex:1; min-width:105px; max-width:155px;
      border:2px solid var(--rim); border-radius:18px;
      padding:16px 10px; cursor:pointer; text-align:center;
      background:var(--surface);
      transition:transform .2s, border-color .2s, background .2s;
    }
    .diff-btn:nth-child(1){ animation:fadeUp .6s .55s ease both; }
    .diff-btn:nth-child(2){ animation:fadeUp .6s .65s ease both; }
    .diff-btn:nth-child(3){ animation:fadeUp .6s .75s ease both; }
    .diff-btn .d-icon { font-size:30px; }
    .diff-btn .d-name { display:block; font-size:.88rem; font-weight:700; margin-top:5px; }
    .diff-btn .d-hint { display:block; font-size:.68rem; color:#c9a070; margin-top:3px; line-height:1.4; }
    .diff-btn:hover   { transform:translateY(-3px); border-color:var(--gold); }
    .diff-btn.active[data-diff="easy"]   { border-color:var(--easy); box-shadow:0 0 16px rgba(76,175,80,.5);   background:linear-gradient(145deg,#1a3a1a,#0d2a0d); }
    .diff-btn.active[data-diff="medium"] { border-color:var(--med);  box-shadow:0 0 16px rgba(244,168,64,.5);  background:linear-gradient(145deg,#4A2500,#3A1800); }
    .diff-btn.active[data-diff="hard"]   { border-color:var(--hard); box-shadow:0 0 16px rgba(229,57,53,.5);   background:linear-gradient(145deg,#3a0d0d,#220606); }

    /* â•â• MEMORY GAME SCREEN â•â• */
    #game-screen { width:100%; max-width:640px; animation:fadeIn .5s ease; }

    .game-header { text-align:center; margin-bottom:18px; }
    .game-owl    { font-size:52px; line-height:1; filter:drop-shadow(0 0 16px rgba(244,168,64,.7)); animation:floatOwl 3s ease-in-out infinite; }
    .game-title  { font-size:clamp(1.4rem,4.5vw,2rem); font-weight:900; color:var(--gold); text-shadow:0 2px 10px rgba(244,168,64,.45); }
    .game-title span { color:var(--accent); }

    .diff-badge        { display:inline-block; font-size:.72rem; font-weight:700; letter-spacing:1px; padding:3px 14px; border-radius:50px; margin-top:4px; text-transform:uppercase; }
    .diff-badge.easy   { background:rgba(76,175,80,.2);  border:1px solid var(--easy);  color:var(--easy);  }
    .diff-badge.medium { background:rgba(244,168,64,.2); border:1px solid var(--med);   color:var(--med);   }
    .diff-badge.hard   { background:rgba(229,57,53,.2);  border:1px solid var(--hard);  color:var(--hard);  }

    .stats     { display:flex; gap:14px; justify-content:center; margin-bottom:18px; flex-wrap:wrap; }
    .stat-box  { background:var(--surface); border:1.5px solid var(--rim); border-radius:14px; padding:9px 20px; text-align:center; min-width:100px; }
    .stat-label { font-size:.68rem; color:#c9a070; text-transform:uppercase; letter-spacing:1px; }
    .stat-value { font-size:1.5rem; font-weight:900; color:var(--gold); }

    #preview-bar { display:none; width:100%; max-width:580px; margin-bottom:14px; text-align:center; }
    #preview-bar .pb-label { font-size:.82rem; color:var(--gold); font-weight:700; margin-bottom:6px; }
    .progress-track { width:100%; height:9px; background:rgba(255,255,255,.1); border-radius:50px; overflow:hidden; }
    .progress-fill  { height:100%; border-radius:50px; background:linear-gradient(90deg,var(--accent),var(--gold)); transition:width .1s linear; }

    #game-grid { display:grid; grid-template-columns:repeat(4,1fr); gap:12px; width:100%; }

    .card       { aspect-ratio:3/4; perspective:800px; cursor:pointer; }
    .card-inner { width:100%; height:100%; position:relative; transform-style:preserve-3d; transition:transform .45s cubic-bezier(.4,0,.2,1); border-radius:16px; }
    .card.flipped .card-inner, .card.matched .card-inner, .card.preview .card-inner { transform:rotateY(180deg); }
    .card-face  { position:absolute; inset:0; border-radius:16px; backface-visibility:hidden; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:5px; padding:6px; user-select:none; }
    .card-back  { background:linear-gradient(145deg,#7A3E18,#4A2108); border:2.5px solid var(--rim); box-shadow:0 4px 16px var(--shadow),inset 0 1px 0 rgba(255,255,255,.08); }
    .card-back-inner { width:72%; height:72%; border:1.5px dashed rgba(244,168,64,.35); border-radius:12px; display:flex; align-items:center; justify-content:center; font-size:clamp(1.6rem,5vw,2.6rem); opacity:.85; }
    .card-front    { background:linear-gradient(145deg,#FDF6EC,#F0DFC0); border:2.5px solid var(--gold); box-shadow:0 4px 16px var(--shadow); transform:rotateY(180deg); color:var(--dark); }
    .card-emoji    { font-size:clamp(2rem,6.5vw,3rem); line-height:1; }
    .card-name-en  { font-size:clamp(.58rem,1.8vw,.76rem); font-weight:700; color:var(--cb); letter-spacing:.5px; text-transform:uppercase; }
    .card-name-ar  { font-size:clamp(.62rem,1.9vw,.8rem); font-weight:600; color:#6B3F1A; }
    .card.matched .card-front { background:linear-gradient(145deg,#fff9ee,#ffe8a0); border-color:var(--gold); box-shadow:0 0 22px rgba(244,168,64,.65),0 4px 18px var(--shadow); animation:spinGlow 1.5s ease; }
    .card.wrong .card-inner   { animation:shake .4s ease; }

    /* â•â• MAZE SCREEN â•â• */
    #maze-screen { width:100%; max-width:520px; animation:fadeIn .5s ease; display:none; }
    #pacchick-screen { width:100%; max-width:520px; animation:fadeIn .5s ease; display:none; }

    #maze-canvas {
      display:block; width:100%;
      max-width:420px; margin:0 auto;
      border-radius:16px;
      border:2.5px solid var(--rim);
      box-shadow:0 4px 24px var(--shadow);
      background:#1a0900;
    }

    /* D-Pad */
    .dpad { display:grid; grid-template-columns:repeat(3,54px); grid-template-rows:repeat(3,54px); gap:6px; justify-content:center; margin-top:18px; direction:ltr; }
    .dpad-btn {
      width:54px; height:54px; border-radius:14px;
      background:var(--surface); border:2px solid var(--rim);
      color:var(--cream); font-size:1.3rem; cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      transition:background .15s, transform .1s, border-color .15s;
      user-select:none; -webkit-user-select:none; touch-action:manipulation;
    }
    .dpad-btn:active, .dpad-btn.pressed { background:var(--cb); transform:scale(.92); border-color:var(--gold); }
    .dpad-center { background:transparent; border:none; cursor:default; font-size:1.5rem; pointer-events:none; }

    /* â•â• SHARED BUTTONS â•â• */
    .action-row { display:flex; gap:12px; justify-content:center; margin-top:22px; flex-wrap:wrap; }
    .btn { background:linear-gradient(135deg,var(--accent),#c96020); border:none; color:#fff; font-family:'Cairo',sans-serif; font-size:.95rem; font-weight:700; padding:11px 32px; border-radius:50px; cursor:pointer; box-shadow:0 4px 18px rgba(232,132,62,.4); transition:transform .15s,box-shadow .15s; }
    .btn:hover  { transform:translateY(-2px); box-shadow:0 8px 24px rgba(232,132,62,.55); }
    .btn:active { transform:translateY(0); }
    .btn.outline { background:transparent; border:2px solid var(--rim); color:var(--cream); box-shadow:none; }
    .btn.outline:hover { border-color:var(--gold); }

    /* â•â• COMBO TOAST â•â• */
    #combo-toast { display:none; position:fixed; left:50%; top:45%; transform:translate(-50%,-50%); z-index:350; background:linear-gradient(135deg,#4A2500,#2a1200); border:2px solid var(--gold); border-radius:20px; padding:18px 32px; text-align:center; box-shadow:0 0 40px rgba(244,168,64,.65); pointer-events:none; }
    #combo-toast.show { display:block; animation:popIn .35s ease; }
    #combo-toast .ct-icon { font-size:2.4rem; line-height:1; }
    #combo-toast .ct-text { font-size:1.05rem; font-weight:900; color:var(--gold); margin-top:6px; }

    /* â•â• TIME BAR â•â• */
    .time-bar-wrap { width:100%; max-width:580px; margin-bottom:12px; }
    .time-bar-track { width:100%; height:7px; background:rgba(255,255,255,.1); border-radius:50px; overflow:hidden; }
    .time-bar-fill { height:100%; border-radius:50px; background:linear-gradient(90deg,var(--easy),var(--gold)); transition:width 1s linear; }
    .time-bar-fill.warn { background:linear-gradient(90deg,var(--hard),#ff7a00) !important; }
    .stat-value.warn { color:var(--hard) !important; animation:pulse .5s ease-in-out infinite; }

    @keyframes fadeOut { from{opacity:1;transform:scale(1)} to{opacity:0;transform:scale(.97)} }
    .game-fading { animation:fadeOut .6s ease forwards; pointer-events:none; }

    /* â•â• MUTE BUTTON â•â• */
    .mute-btn { position:fixed; top:14px; right:14px; z-index:250; background:var(--surface); border:1.5px solid var(--rim); border-radius:50%; width:40px; height:40px; font-size:19px; cursor:pointer; transition:border-color .2s, transform .15s; display:none; align-items:center; justify-content:center; padding:0; }
    .mute-btn:hover { border-color:var(--gold); transform:scale(1.1); }
    .mute-btn.active { display:flex; }

    /* â•â• WIN SCREEN â•â• */
    #win-screen { display:none; position:fixed; inset:0; background:rgba(15,5,0,.88); backdrop-filter:blur(6px); z-index:300; flex-direction:column; align-items:center; justify-content:center; text-align:center; padding:24px; animation:fadeIn .5s ease; }
    #win-screen.show { display:flex; }
    .win-box   { background:linear-gradient(145deg,#3B1800,#5C2C08); border:2px solid var(--gold); border-radius:28px; padding:36px 44px; max-width:420px; width:100%; box-shadow:0 0 60px rgba(244,168,64,.3); animation:popIn .5s ease; }
    .win-owl   { font-size:76px; animation:floatOwl 2s ease-in-out infinite; }
    .win-title { font-size:1.9rem; font-weight:900; color:var(--gold); margin:10px 0 5px; }
    .win-sub   { color:#c9a070; font-size:.9rem; margin-bottom:18px; }
    .win-stats { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-bottom:20px; }
    .win-stat  { background:rgba(0,0,0,.3); border:1px solid var(--rim); border-radius:12px; padding:10px 16px; }
    .win-stat .label { font-size:.68rem; color:#c9a070; text-transform:uppercase; }
    .win-stat .val   { font-size:1.45rem; font-weight:900; color:var(--gold); }
    .stars { font-size:2.2rem; margin:5px 0 16px; letter-spacing:4px; }
    .star  { display:inline-block; animation:starPop .4s ease both; }

    .new-best      { display:none; font-size:.7rem; font-weight:900; color:var(--gold); letter-spacing:1px; text-transform:uppercase; margin-top:2px; }
    .new-best.show { display:block; }

    .discount-banner      { display:none; background:linear-gradient(135deg,#1a3a1a,#0d2a0d); border:2px solid var(--easy); border-radius:16px; padding:16px 20px; margin-bottom:18px; animation:popIn .5s .6s ease both; box-shadow:0 0 20px rgba(76,175,80,.35); }
    .discount-banner.show { display:block; }
    .discount-pct         { font-size:1.9rem; font-weight:900; color:var(--easy); line-height:1; }
    .discount-text-ar     { font-size:.83rem; font-weight:600; color:#c9a070; margin-top:4px; line-height:1.5; }
    .discount-text-en     { font-size:.78rem; color:#a08060; margin-top:2px; }
    .disc-code-wrap       { margin:10px 0 6px; }
    .disc-code-label      { font-size:.62rem; color:#a0c890; text-transform:uppercase; letter-spacing:1.5px; margin-bottom:5px; }
    .disc-code            { font-size:1.55rem; font-weight:900; color:#fff; background:rgba(0,0,0,.4); border:1.5px dashed rgba(76,210,90,.7); border-radius:12px; padding:8px 18px; letter-spacing:5px; font-family:monospace,'Cairo',sans-serif; display:inline-block; min-width:180px; }

    .confetti-dot { position:fixed; border-radius:2px; pointer-events:none; z-index:400; animation:confettiFall linear forwards; }

    @media(max-width:420px) {
      #game-grid{gap:8px;} .win-box{padding:28px 18px;}
      .dpad-btn{width:46px;height:46px;} .game-cards{flex-direction:column;align-items:center;}
    }
  </style>
</head>
<body>

<!-- Floating mute toggle -->
<button class="mute-btn" id="mute-btn" onclick="toggleMute()" title="Mute / ÙƒØªÙ…">ğŸ”Š</button>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     HOME SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="home" class="screen-overlay">
  <div class="home-logo">ğŸ¦‰</div>
  <div class="home-brand">Seelaz <span>Games</span></div>
  <div class="home-tagline">Ø§Ù„Ø¹Ø¨ ÙˆØ§ÙƒØ³Ø¨ Ø®ØµÙ… Ù‚Ù‡ÙˆØªÙƒ</div>

  <div class="game-cards">

    <div class="game-card" id="card-memory" onclick="selectGame('memory')">
      <span class="gc-icon">ğŸƒ</span>
      <div class="gc-name">Ù„Ø¹Ø¨Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø©</div>
      <div class="gc-desc">Ø·Ø§Ø¨Ù‚ Ø£Ø²ÙˆØ§Ø¬ Ø§Ù„ÙƒØ±ÙˆØª Ø¨Ø£Ø³Ø±Ø¹ ÙˆÙ‚Øª</div>
    </div>

    <div class="game-card" id="card-maze" onclick="selectGame('maze')">
      <span class="gc-icon">ğŸŒ€</span>
      <div class="gc-name">Ù…ØªØ§Ù‡Ø© Ø§Ù„Ø¨ÙˆÙ…Ø©</div>
      <div class="gc-desc">ÙˆØµÙ‘Ù„ Ø§Ù„Ø¨ÙˆÙ…Ø© Ù„Ù„Ù‚Ù‡ÙˆØ© Ø¹Ø¨Ø± Ø§Ù„Ù…ØªØ§Ù‡Ø©</div>
    </div>

    <div class="game-card" id="card-pacchick" onclick="selectGame('pacchick')">
      <span class="gc-icon">ğŸ¥</span>
      <div class="gc-name">Ø¨Ø§Ùƒ ØªØ´ÙŠÙƒ</div>
      <div class="gc-desc">ÙƒÙ„ Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ø¨Ø¹Ø¯ Ø¹Ù† Ø§Ù„Ø£Ø´Ø¨Ø§Ø­!</div>
    </div>

  </div>

  <button class="home-play-btn" id="home-play-btn" onclick="startGame()">â˜• Ù‡ÙŠØ§ Ù†Ù„Ø¹Ø¨!</button>

  <!-- Inline settings (shown after card selection) -->
  <div id="home-settings">
    <div class="section-label">ğŸŒ Ø§Ù„Ù„ØºØ©</div>
    <div class="choice-row">
      <button class="lang-btn active" data-lang="ar" onclick="selectLang(this)">
        <div class="l-flag">ğŸ‡¸ğŸ‡¦</div>
        <span class="l-name">Ø¹Ø±Ø¨ÙŠ</span>
        <span class="l-sub">Ø¹Ø±Ø¨ÙŠ ÙÙ‚Ø·</span>
      </button>
      <button class="lang-btn" data-lang="en" onclick="selectLang(this)">
        <div class="l-flag">ğŸ‡ºğŸ‡¸</div>
        <span class="l-name">English</span>
        <span class="l-sub">English only</span>
      </button>
    </div>

    <div class="section-label">âš¡ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµØ¹ÙˆØ¨Ø©</div>
    <div class="choice-row">
      <button class="diff-btn active" data-diff="easy" onclick="selectDiff(this)">
        <div class="d-icon">ğŸŸ¢</div>
        <span class="d-name" style="color:var(--easy)">Ø³Ù‡Ù„</span>
        <span class="d-hint"></span>
      </button>
      <button class="diff-btn" data-diff="medium" onclick="selectDiff(this)">
        <div class="d-icon">ğŸŸ¡</div>
        <span class="d-name" style="color:var(--med)">Ù…ØªÙˆØ³Ø·</span>
        <span class="d-hint"></span>
      </button>
      <button class="diff-btn" data-diff="hard" onclick="selectDiff(this)">
        <div class="d-icon">ğŸ”´</div>
        <span class="d-name" style="color:var(--hard)">ØµØ¹Ø¨</span>
        <span class="d-hint"></span>
      </button>
    </div>
  </div>
</div>



<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     MEMORY GAME SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="game-screen" style="display:none;">
  <div class="game-header">
    <div class="game-owl">ğŸ¦‰</div>
    <div class="game-title">Owl <span>Memory</span></div>
    <div class="diff-badge" id="diff-badge"></div>
  </div>

  <div class="stats">
    <div class="stat-box">
      <div class="stat-label">Ø­Ø±ÙƒØ§Øª</div>
      <div class="stat-value" id="moves-val">0</div>
    </div>
    <div class="stat-box">
      <div class="stat-label">Ø£Ø²ÙˆØ§Ø¬</div>
      <div class="stat-value" id="pairs-val">0 / 8</div>
    </div>
    <div class="stat-box">
      <div class="stat-label">ÙˆÙ‚Øª</div>
      <div class="stat-value" id="timer-val">0:00</div>
    </div>
  </div>

  <div class="time-bar-wrap"><div class="time-bar-track"><div class="time-bar-fill" id="mem-tb-fill"></div></div></div>

  <div id="preview-bar">
    <div class="pb-label">ğŸ‘€ Ø§Ø­ÙØ¸ Ø§Ù„ÙƒØ±ÙˆØª!</div>
    <div class="progress-track"><div class="progress-fill" id="progress-fill" style="width:100%"></div></div>
  </div>

  <div id="game-grid"></div>

  <div class="action-row">
    <button class="btn" onclick="restartSame()">ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø©</button>
    <button class="btn outline" onclick="goToHome()">ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
  </div>
</div>


<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     MAZE GAME SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="maze-screen">
  <div class="game-header maze-header">
    <div class="game-owl">ğŸ¦‰</div>
    <div class="game-title">Owl <span>Maze</span></div>
    <div class="diff-badge" id="maze-diff-badge"></div>
  </div>

  <div class="stats">
    <div class="stat-box">
      <div class="stat-label">Ø®Ø·ÙˆØ§Øª</div>
      <div class="stat-value" id="maze-steps-val">0</div>
    </div>
    <div class="stat-box">
      <div class="stat-label">ÙˆÙ‚Øª</div>
      <div class="stat-value" id="maze-timer-val">1:00</div>
    </div>
  </div>

  <div class="time-bar-wrap"><div class="time-bar-track"><div class="time-bar-fill" id="maze-tb-fill"></div></div></div>

  <canvas id="maze-canvas"></canvas>

  <!-- On-screen D-Pad -->
  <div class="dpad">
    <button class="dpad-btn" id="btn-up"    style="grid-column:2;grid-row:1" onpointerdown="dpadPress(this,'N')" onpointerup="dpadRelease(this)" onpointerleave="dpadRelease(this)">â†‘</button>
    <button class="dpad-btn" id="btn-left"  style="grid-column:1;grid-row:2" onpointerdown="dpadPress(this,'W')" onpointerup="dpadRelease(this)" onpointerleave="dpadRelease(this)">â†</button>
    <div class="dpad-btn dpad-center"        style="grid-column:2;grid-row:2">ğŸ¦‰</div>
    <button class="dpad-btn" id="btn-right" style="grid-column:3;grid-row:2" onpointerdown="dpadPress(this,'E')" onpointerup="dpadRelease(this)" onpointerleave="dpadRelease(this)">â†’</button>
    <button class="dpad-btn" id="btn-down"  style="grid-column:2;grid-row:3" onpointerdown="dpadPress(this,'S')" onpointerup="dpadRelease(this)" onpointerleave="dpadRelease(this)">â†“</button>
  </div>

  <div class="action-row">
    <button class="btn" onclick="restartMaze()">ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø©</button>
    <button class="btn outline" onclick="goToHome()">ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     PAC-CHICK GAME SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="pacchick-screen">
  <div class="game-header maze-header">
    <div class="game-owl">ğŸ¥</div>
    <div class="game-title" id="pc-game-title">Pac <span>Chick</span></div>
    <div class="diff-badge" id="pc-diff-badge"></div>
  </div>

  <div class="stats">
    <div class="stat-box">
      <div class="stat-label" id="pc-lbl-score">Ù†Ù‚Ø§Ø·</div>
      <div class="stat-value" id="pc-score-val">0</div>
    </div>
    <div class="stat-box">
      <div class="stat-label" id="pc-lbl-lives">Ø£Ø±ÙˆØ§Ø­</div>
      <div class="stat-value" id="pc-lives-val">ğŸ¥ğŸ¥ğŸ¥</div>
    </div>
    <div class="stat-box">
      <div class="stat-label" id="pc-lbl-time">ÙˆÙ‚Øª</div>
      <div class="stat-value" id="pc-timer-val">2:00</div>
    </div>
  </div>

  <div class="time-bar-wrap"><div class="time-bar-track"><div class="time-bar-fill" id="pc-tb-fill"></div></div></div>

  <canvas id="pacchick-canvas"></canvas>

  <div class="dpad">
    <button class="dpad-btn" style="grid-column:2;grid-row:1" onpointerdown="pcDir('up')">â†‘</button>
    <button class="dpad-btn" style="grid-column:1;grid-row:2" onpointerdown="pcDir('left')">â†</button>
    <div class="dpad-btn dpad-center" style="grid-column:2;grid-row:2">ğŸ¥</div>
    <button class="dpad-btn" style="grid-column:3;grid-row:2" onpointerdown="pcDir('right')">â†’</button>
    <button class="dpad-btn" style="grid-column:2;grid-row:3" onpointerdown="pcDir('down')">â†“</button>
  </div>

  <div class="action-row">
    <button class="btn" id="pc-btn-restart" onclick="restartPacChick()">ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø©</button>
    <button class="btn outline" id="pc-btn-home" onclick="goToHome()">ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
  </div>
</div>

<!-- Combo / Timeout toast (shared) -->
<div id="combo-toast"><div class="ct-icon">ğŸ¦‰</div><div class="ct-text"></div></div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     WIN SCREEN  (shared)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="win-screen">
  <div class="win-box">
    <div class="win-owl">ğŸ¦‰</div>
    <div class="win-title">ğŸ‰ Ù…Ù…ØªØ§Ø²!</div>
    <div class="win-sub" id="win-sub">All pairs matched!</div>
    <div class="stars" id="stars-row"></div>
    <div class="discount-banner" id="discount-banner">
      <div class="discount-pct" id="discount-pct"></div>
      <div class="discount-text-ar" id="discount-text-ar"></div>
      <div class="disc-code-wrap">
        <div class="disc-code-label">ÙƒÙˆØ¯ Ø§Ù„Ø®ØµÙ…</div>
        <div class="disc-code" id="disc-code">â€”</div>
      </div>
      <div class="discount-text-en" id="discount-text-en"></div>
    </div>
    <div class="win-stats">
      <div class="win-stat">
        <div class="label" id="ws-label1">Moves</div>
        <div class="val"   id="final-stat1">-</div>
      </div>
      <div class="win-stat">
        <div class="label" id="ws-label-time">ÙˆÙ‚Øª</div>
        <div class="val" id="final-time">-</div>
      </div>
      <div class="win-stat">
        <div class="label" id="ws-label-score">Ù†Ù‚Ø§Ø·</div>
        <div class="val" id="final-score">-</div>
      </div>
      <div class="win-stat">
        <div class="label" id="ws-label-best">ğŸ† Ø£ÙØ¶Ù„</div>
        <div class="val" id="hs-val">-</div>
        <div class="new-best" id="new-best-badge">â­ Ø¬Ø¯ÙŠØ¯!</div>
      </div>
    </div>
    <div class="action-row" style="margin-top:0">
      <button class="btn" onclick="playAgainWin()">â˜• Ø§Ù„Ø¹Ø¨ ØªØ§Ù†ÙŠ</button>
      <button class="btn outline" onclick="goToHomeWin()">ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
    </div>
  </div>
</div>


<script>
/* â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
   â­  ALL GAME SETTINGS LIVE HERE â€” edit only this block  â­
   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const CFG = {

  // â”€â”€ Brand â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  brand:      'Seelaz',
  website:    'seelaz.com',
  taglineAr:  'Ø§Ù„Ø¹Ø¨ ÙˆØ§ÙƒØ³Ø¨ Ø®ØµÙ… Ù‚Ù‡ÙˆØªÙƒ',
  taglineEn:  'Play & Win a Coffee Discount',

  // â”€â”€ Game names & descriptions (ar + en) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  games: {
    memory: {
      nameEn:'Owl Memory', nameAr:'Ù„Ø¹Ø¨Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø©', icon:'ğŸƒ',
      descEn:'Match all coffee card pairs as fast as you can',
      descAr:'Ø·Ø§Ø¨Ù‚ Ø£Ø²ÙˆØ§Ø¬ Ø§Ù„ÙƒØ±ÙˆØª Ø¨Ø£Ø³Ø±Ø¹ ÙˆÙ‚Øª',
    },
    maze: {
      nameEn:'Owl Maze', nameAr:'Ù…ØªØ§Ù‡Ø© Ø§Ù„Ø¨ÙˆÙ…Ø©', icon:'ğŸŒ€',
      descEn:'Guide the owl through the maze to reach the coffee',
      descAr:'ÙˆØµÙ‘Ù„ Ø§Ù„Ø¨ÙˆÙ…Ø© Ù„Ù„Ù‚Ù‡ÙˆØ© Ø¹Ø¨Ø± Ø§Ù„Ù…ØªØ§Ù‡Ø©',
    },
    pacchick: {
      nameEn:'Pac-Chick', nameAr:'Ø¨Ø§Ùƒ ØªØ´ÙŠÙƒ', icon:'ğŸ¥',
      descEn:'Eat all the pellets and dodge the ghosts!',
      descAr:'ÙƒÙ„ ÙƒÙ„ Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ø¨Ø¹Ø¯ Ø¹Ù† Ø§Ù„Ø£Ø´Ø¨Ø§Ø­!',
    },
  },

  // â”€â”€ Time limits per game & difficulty (seconds) â”€â”€â”€â”€â”€â”€â”€â”€â”€
  timeLimits: {
    memory:   { easy:40,  medium:55,  hard:75  },
    maze:     { easy:45,  medium:65,  hard:95  },
    pacchick: { easy:120, medium:100, hard:80  },
  },

  // â”€â”€ Memory: pair counts & card-preview duration (ms) â”€â”€â”€â”€
  memPairs:  { easy:4,    medium:6,    hard:8   },
  previewMs: { easy:3000, medium:1500, hard:500 },

  // â”€â”€ Maze: grid size in cells (must be odd numbers) â”€â”€â”€â”€â”€â”€
  mazeSize:  { easy:9, medium:13, hard:17 },

  // â”€â”€ Discount percentages â€” 3-star wins only (0 = none) â”€â”€
  discount: {
    memory:   { easy:0, medium:5, hard:10 },
    maze:     { easy:0, medium:5, hard:10 },
    pacchick: { easy:0, medium:5, hard:10 },
  },

  // â”€â”€ Discount code prefix  e.g. SLZ-M5-AB3K â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  codePrefix: 'SLZ',

  // â”€â”€ Scoring: speed 60% + efficiency 40% = max 1000 pts â”€â”€
  scoring: {
    memory:   { speedWeight:600, effWeight:400, mistakePenalty:30 },
    maze:     { speedWeight:600, effWeight:400, extraStepPenalty:6 },
    pacchick: { speedWeight:300, pelletsWeight:700 },  // speed 30% + pellets 70%
    starThresholds: [820, 580],  // [3-star min, 2-star min]
  },

};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DATA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const MEMORY_CARDS = [
  { emoji:'â˜•', en:'Espresso',    ar:'Ø¥Ø³Ø¨Ø±ÙŠØ³Ùˆ'  },
  { emoji:'ğŸ¥', en:'Croissant',  ar:'ÙƒØ±ÙˆØ§Ø³ÙˆÙ†'  },
  { emoji:'ğŸ«', en:'Chocolate',  ar:'Ø´ÙˆÙƒÙˆÙ„Ø§ØªØ©' },
  { emoji:'ğŸ§', en:'Cupcake',    ar:'ÙƒØ¨ ÙƒÙŠÙƒ'   },
  { emoji:'ğŸ«˜', en:'Coffee Bean',ar:'Ø­Ø¨Ø© Ù‚Ù‡ÙˆØ©' },
  { emoji:'ğŸ¥›', en:'Milk',       ar:'Ù„Ø¨Ù†'       },
  { emoji:'ğŸ¯', en:'Honey',      ar:'Ø¹Ø³Ù„'       },
  { emoji:'ğŸ§‹', en:'Bubble Tea', ar:'Ø¨Ø§Ø¨Ù„ ØªÙŠ'  },
];

// â”€â”€ CFG aliases â€” do not edit here, edit CFG above â”€â”€
const PREVIEW_MS      = CFG.previewMs;
const MEM_PAIRS       = CFG.memPairs;
const MEM_TIME_LIMIT  = CFG.timeLimits.memory;
const MAZE_TIME_LIMIT = CFG.timeLimits.maze;
const MAZE_SIZE       = CFG.mazeSize;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TRANSLATIONS  T[lang].key
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const T = {
  ar: {
    tagline:       'Ø§Ù„Ø¹Ø¨ ÙˆØ§ÙƒØ³Ø¨ Ø®ØµÙ… Ù‚Ù‡ÙˆØªÙƒ',
    playBtn:       'â˜• Ù‡ÙŠØ§ Ù†Ù„Ø¹Ø¨!',
    secLang:       'ğŸŒ Ø§Ù„Ù„ØºØ©',
    secDiff:       'âš¡ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµØ¹ÙˆØ¨Ø©',
    diff:          { easy:'Ø³Ù‡Ù„', medium:'Ù…ØªÙˆØ³Ø·', hard:'ØµØ¹Ø¨' },
    diffBadge:     { easy:'ğŸŸ¢ Ø³Ù‡Ù„', medium:'ğŸŸ¡ Ù…ØªÙˆØ³Ø·', hard:'ğŸ”´ ØµØ¹Ø¨' },
    memHint:       { easy:'Ù¨ ÙƒØ±ÙˆØª', medium:'Ù¡Ù¢ ÙƒØ±Øª', hard:'Ù¡Ù¦ ÙƒØ±Øª' },
    mazeHint:      { easy:'Ø´Ø¨ÙƒØ© Ù©Ã—Ù©', medium:'Ø´Ø¨ÙƒØ© Ù¡Ù£Ã—Ù¡Ù£', hard:'Ø´Ø¨ÙƒØ© Ù¡Ù§Ã—Ù¡Ù§' },
    memTitleHTML:  'Ù„Ø¹Ø¨Ø© <span>Ø§Ù„Ø°Ø§ÙƒØ±Ø©</span>',
    mazeTitleHTML: 'Ù…ØªØ§Ù‡Ø© <span>Ø§Ù„Ø¨ÙˆÙ…Ø©</span>',
    statMoves: 'Ø­Ø±ÙƒØ§Øª',  statPairs: 'Ø£Ø²ÙˆØ§Ø¬',  statSteps: 'Ø®Ø·ÙˆØ§Øª',  statTime: 'ÙˆÙ‚Øª',
    memorize:  'ğŸ‘€ Ø§Ø­ÙØ¸ Ø§Ù„ÙƒØ±ÙˆØª!',
    restart:   'ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø©',  goHome: 'ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©',
    winTitle:  'ğŸ‰ Ù…Ù…ØªØ§Ø²!',
    winSubMem: 'ÙˆØ¬Ø¯Øª ÙƒÙ„ Ø§Ù„Ø£Ø²ÙˆØ§Ø¬! ğŸƒ',  winSubMaze: 'Ø§Ù„Ø¨ÙˆÙ…Ø© ÙˆØµÙ„Øª Ù„Ù„Ù‚Ù‡ÙˆØ©! â˜•',  winSubPacchick: 'Ø£ÙƒÙ„Øª ÙƒÙ„ Ø§Ù„Ù†Ù‚Ø§Ø·! ğŸ¥',
    lMoves: 'Ø­Ø±ÙƒØ§Øª',  lSteps: 'Ø®Ø·ÙˆØ§Øª',  lTime: 'ÙˆÙ‚Øª',  lScore: 'Ù†Ù‚Ø§Ø·',  lBest: 'ğŸ† Ø£ÙØ¶Ù„',
    playAgain: 'â˜• Ø§Ù„Ø¹Ø¨ ØªØ§Ù†ÙŠ',  codeLabel: 'ÙƒÙˆØ¯ Ø§Ù„Ø®ØµÙ…',
    timeout:   'Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª!',
    combo:     'Ù…Ø¨Ø±ÙˆÙƒ! Ù¤ Ù…ØªØ§Ø¨Ø¹Ø© ğŸ”¥',
    newBest:   'â­ Ø¬Ø¯ÙŠØ¯!',
    pcTitleHTML:  'Ø¨Ø§Ùƒ <span>ØªØ´ÙŠÙƒ</span>',
    pcHint:    { easy:'Ù£ Ø£Ø´Ø¨Ø§Ø­ Ø¨Ø·ÙŠØ¦Ø©', medium:'Ù£ Ø£Ø´Ø¨Ø§Ø­', hard:'Ù¤ Ø£Ø´Ø¨Ø§Ø­ Ø³Ø±ÙŠØ¹Ø©' },
    pcScore:   'Ù†Ù‚Ø§Ø·',  pcLives: 'Ø£Ø±ÙˆØ§Ø­',
  },
  en: {
    tagline:       'Play & Win a Coffee Discount',
    playBtn:       "\u2615 Let's Play!",
    secLang:       'ğŸŒ Language',
    secDiff:       'âš¡ Difficulty',
    diff:          { easy:'Easy', medium:'Medium', hard:'Hard' },
    diffBadge:     { easy:'ğŸŸ¢ Easy', medium:'ğŸŸ¡ Medium', hard:'ğŸ”´ Hard' },
    memHint:       { easy:'8 cards', medium:'12 cards', hard:'16 cards' },
    mazeHint:      { easy:'9Ã—9 grid', medium:'13Ã—13 grid', hard:'17Ã—17 grid' },
    memTitleHTML:  'Owl <span>Memory</span>',
    mazeTitleHTML: 'Owl <span>Maze</span>',
    statMoves: 'Moves',  statPairs: 'Pairs',  statSteps: 'Steps',  statTime: 'Time',
    memorize:  'ğŸ‘€ Memorize!',
    restart:   'ğŸ”„ Restart',  goHome: 'ğŸ  Home',
    winTitle:  'ğŸ‰ Excellent!',
    winSubMem: 'All card pairs matched! ğŸƒ',  winSubMaze: 'The owl reached the coffee! â˜•',  winSubPacchick: 'All pellets eaten! ğŸ¥',
    lMoves: 'Moves',  lSteps: 'Steps',  lTime: 'Time',  lScore: 'Score',  lBest: 'ğŸ† Best',
    playAgain: 'â˜• Play Again',  codeLabel: 'Discount Code',
    timeout:   "Time's up!",
    combo:     'Combo Ã—4! ğŸ”¥',
    newBest:   'â­ NEW!',
    pcTitleHTML:  'Pac <span>Chick</span>',
    pcHint:    { easy:'2 ghosts (slow)', medium:'3 ghosts', hard:'4 ghosts (fast)' },
    pcScore:   'Score',  pcLives: 'Lives',
  },
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SETTINGS & STATE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
// â”€â”€ State: game & navigation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentGame = '';   // 'memory' | 'maze'
let chosenLang  = 'ar';
let chosenDiff  = 'easy';
let muted       = false;

// â”€â”€ State: memory game â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let deck, memFlipped, memMatched, memMoves, memLocked, memTimerID, memSeconds, memActive, previewTID;
let memStreak = 0, memTotalPairs = 4;

// â”€â”€ State: maze game â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let mazeGrid = [], mazeCols = 0, mazeRows = 0;
let playerX = 0, playerY = 0, goalX = 0, goalY = 0;
let mazeSteps = 0, mazeTimerID, mazeSeconds = 0, mazeActive = false, mazeOptimal = 1;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   NAVIGATION â€” HOME
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function selectGame(game) {
  currentGame = game;
  document.getElementById('card-memory').classList.toggle('active', game === 'memory');
  document.getElementById('card-maze').classList.toggle('active', game === 'maze');
  document.getElementById('card-pacchick').classList.toggle('active', game === 'pacchick');
  updateDiffHints();
  document.querySelectorAll('.lang-btn').forEach(b => b.classList.toggle('active', b.dataset.lang === chosenLang));
  document.querySelectorAll('.diff-btn').forEach(b => b.classList.toggle('active', b.dataset.diff === chosenDiff));
  document.getElementById('home-settings').classList.add('show');
  document.getElementById('home-play-btn').classList.add('show');
}

function goToHome() {
  stopMemTimer(); clearTimeout(previewTID);
  stopMazeTimer();
  stopPacChick();
  document.getElementById('game-screen').style.display = 'none';
  document.getElementById('maze-screen').style.display = 'none';
  document.getElementById('pacchick-screen').style.display = 'none';
  document.getElementById('mute-btn').classList.remove('active');
  currentGame = '';
  document.getElementById('card-memory').classList.remove('active');
  document.getElementById('card-maze').classList.remove('active');
  document.getElementById('card-pacchick').classList.remove('active');
  document.getElementById('home-settings').classList.remove('show');
  document.getElementById('home-play-btn').classList.remove('show');
  showOverlay('home');
}

function goToHomeWin() {
  document.getElementById('win-screen').classList.remove('show');
  goToHome();
}

function playAgainWin() {
  document.getElementById('win-screen').classList.remove('show');
  applyLang();
  if (currentGame === 'memory') initMemory();
  else if (currentGame === 'maze') requestAnimationFrame(() => requestAnimationFrame(() => initMaze()));
  else initPacChick();
}

function showOverlay(id) {
  ['home'].forEach(sid => {
    const el = document.getElementById(sid);
    if (sid === id) { el.classList.remove('hidden'); }
    else            { el.classList.add('hidden'); }
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LANGUAGE / DIFFICULTY SELECTORS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function selectLang(btn) {
  document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  chosenLang = btn.dataset.lang;
  applyLang();
}

function selectDiff(btn) {
  document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  chosenDiff = btn.dataset.diff;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LANGUAGE ENGINE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function applyLang() {
  const t   = T[chosenLang];
  const isAr = chosenLang === 'ar';
  document.documentElement.lang = chosenLang;
  document.documentElement.dir  = isAr ? 'rtl' : 'ltr';

  // Home
  document.querySelector('.home-tagline').textContent   = t.tagline;
  document.getElementById('home-play-btn').textContent  = t.playBtn;
  const sls = document.querySelectorAll('#home-settings .section-label');
  if (sls[0]) sls[0].textContent = t.secLang;
  if (sls[1]) sls[1].textContent = t.secDiff;

  // Game cards (single lang)
  ['memory','maze','pacchick'].forEach(g => {
    const c = document.getElementById('card-'+g);
    if (!c) return;
    c.querySelector('.gc-name').textContent = CFG.games[g][isAr ? 'nameAr' : 'nameEn'];
    c.querySelector('.gc-desc').textContent = CFG.games[g][isAr ? 'descAr' : 'descEn'];
  });

  // Diff button names
  document.querySelectorAll('.diff-btn').forEach(b => {
    b.querySelector('.d-name').textContent = t.diff[b.dataset.diff];
  });
  updateDiffHints();

  // Memory screen
  document.querySelector('#game-screen .game-title').innerHTML = t.memTitleHTML;
  const msl = document.querySelectorAll('#game-screen .stat-label');
  if (msl[0]) msl[0].textContent = t.statMoves;
  if (msl[1]) msl[1].textContent = t.statPairs;
  if (msl[2]) msl[2].textContent = t.statTime;
  const pbl = document.querySelector('#preview-bar .pb-label');
  if (pbl) pbl.textContent = t.memorize;
  const mBtns = document.querySelectorAll('#game-screen .action-row .btn');
  if (mBtns[0]) mBtns[0].textContent = t.restart;
  if (mBtns[1]) mBtns[1].textContent = t.goHome;
  if (chosenDiff) {
    const b = document.getElementById('diff-badge');
    if (b) { b.textContent = t.diffBadge[chosenDiff]; b.className = 'diff-badge '+chosenDiff; }
  }

  // Maze screen
  document.querySelector('#maze-screen .game-title').innerHTML = t.mazeTitleHTML;
  const zsl = document.querySelectorAll('#maze-screen .stat-label');
  if (zsl[0]) zsl[0].textContent = t.statSteps;
  if (zsl[1]) zsl[1].textContent = t.statTime;
  const zBtns = document.querySelectorAll('#maze-screen .action-row .btn');
  if (zBtns[0]) zBtns[0].textContent = t.restart;
  if (zBtns[1]) zBtns[1].textContent = t.goHome;
  if (chosenDiff) {
    const bz = document.getElementById('maze-diff-badge');
    if (bz) { bz.textContent = t.diffBadge[chosenDiff]; bz.className = 'diff-badge '+chosenDiff; }
  }

  // Pac-Chick screen
  const pcTitle = document.getElementById('pc-game-title');
  if (pcTitle) pcTitle.innerHTML = t.pcTitleHTML;
  const pcsl = document.querySelectorAll('#pacchick-screen .stat-label');
  if (pcsl[0]) pcsl[0].textContent = t.pcScore;
  if (pcsl[1]) pcsl[1].textContent = t.pcLives;
  if (pcsl[2]) pcsl[2].textContent = t.statTime;
  const pcBtns = document.querySelectorAll('#pacchick-screen .action-row .btn');
  if (pcBtns[0]) pcBtns[0].textContent = t.restart;
  if (pcBtns[1]) pcBtns[1].textContent = t.goHome;
  if (chosenDiff) {
    const bp = document.getElementById('pc-diff-badge');
    if (bp) { bp.textContent = t.diffBadge[chosenDiff]; bp.className = 'diff-badge '+chosenDiff; }
  }
}

function updateDiffHints() {
  if (!currentGame) return;
  const hints = currentGame === 'memory' ? T[chosenLang].memHint
              : currentGame === 'maze'    ? T[chosenLang].mazeHint
              :                            T[chosenLang].pcHint;
  document.querySelectorAll('.diff-btn').forEach(b => {
    b.querySelector('.d-hint').textContent = hints[b.dataset.diff];
  });
}

function startGame() {
  if (!currentGame) return;
  const home = document.getElementById('home');
  home.classList.add('fade-out');
  setTimeout(() => {
    home.classList.add('hidden');
    home.classList.remove('fade-out');
    applyLang();
    document.getElementById('mute-btn').classList.add('active');
    if (currentGame === 'memory') {
      document.getElementById('game-screen').style.display = 'block';
      document.getElementById('maze-screen').style.display = 'none';
      document.getElementById('pacchick-screen').style.display = 'none';
      initMemory();
    } else if (currentGame === 'pacchick') {
      document.getElementById('pacchick-screen').style.display = 'block';
      document.getElementById('game-screen').style.display = 'none';
      document.getElementById('maze-screen').style.display = 'none';
      requestAnimationFrame(() => requestAnimationFrame(() => initPacChick()));
    } else {
      document.getElementById('maze-screen').style.display = 'block';
      document.getElementById('game-screen').style.display = 'none';
      document.getElementById('pacchick-screen').style.display = 'none';
      requestAnimationFrame(() => requestAnimationFrame(() => initMaze()));
    }
  }, 400);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MEMORY GAME
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function initMemory() {
  memFlipped=[]; memMatched=0; memMoves=0; memLocked=false; memSeconds=0; memActive=false;
  memStreak=0;
  stopMemTimer(); clearTimeout(previewTID);

  memTotalPairs = MEM_PAIRS[chosenDiff];
  const timeLimit = MEM_TIME_LIMIT[chosenDiff];

  const badge = document.getElementById('diff-badge');
  badge.textContent = T[chosenLang].diffBadge[chosenDiff];
  badge.className   = 'diff-badge ' + chosenDiff;

  document.getElementById('moves-val').textContent = '0';
  document.getElementById('pairs-val').textContent = '0 / '+memTotalPairs;
  const timerEl = document.getElementById('timer-val');
  timerEl.textContent = Math.floor(timeLimit/60)+':'+(timeLimit%60).toString().padStart(2,'0');
  timerEl.classList.remove('warn');

  // Reset time bar
  const tbFill = document.getElementById('mem-tb-fill');
  tbFill.className = 'time-bar-fill';
  tbFill.style.transition = 'none'; tbFill.style.width = '100%';

  deck = shuffle([...MEMORY_CARDS.slice(0,memTotalPairs), ...MEMORY_CARDS.slice(0,memTotalPairs)].map((c,i) => ({...c, uid:i})));
  renderMemGrid();
  startMemPreview();
}

function restartSame() { initMemory(); }

function renderMemGrid() {
  const grid = document.getElementById('game-grid');
  grid.innerHTML = '';
  deck.forEach((card, idx) => {
    const el = document.createElement('div');
    el.className       = 'card';
    el.dataset.index   = idx;
    el.dataset.emoji   = card.emoji;
    const styleEn = chosenLang === 'ar' ? 'display:none' : '';
    const styleAr = chosenLang === 'en' ? 'display:none' : '';
    el.innerHTML = `
      <div class="card-inner">
        <div class="card-face card-back"><div class="card-back-inner">ğŸ¦‰</div></div>
        <div class="card-face card-front">
          <div class="card-emoji">${card.emoji}</div>
          <div class="card-name-en" style="${styleEn}">${card.en}</div>
          <div class="card-name-ar" style="${styleAr}">${card.ar}</div>
        </div>
      </div>`;
    el.addEventListener('click', onMemCardClick);
    grid.appendChild(el);
  });
}

function startMemPreview() {
  const ms   = PREVIEW_MS[chosenDiff];
  const bar  = document.getElementById('preview-bar');
  const fill = document.getElementById('progress-fill');
  memLocked  = true;
  const cards = document.querySelectorAll('.card');
  cards.forEach((c,i) => setTimeout(() => c.classList.add('preview'), i*40));
  bar.style.display = 'block';
  fill.style.transition = 'none'; fill.style.width = '100%';
  requestAnimationFrame(() => requestAnimationFrame(() => {
    fill.style.transition = `width ${ms}ms linear`;
    fill.style.width = '0%';
  }));
  previewTID = setTimeout(() => {
    bar.style.display = 'none';
    cards.forEach((c,i) => setTimeout(() => c.classList.remove('preview'), i*35));
    setTimeout(() => { memLocked = false; }, cards.length*35+550);
  }, ms);
}

function startMemTimer() {
  clearInterval(memTimerID);
  const limit = MEM_TIME_LIMIT[chosenDiff];
  const tbFill = document.getElementById('mem-tb-fill');
  tbFill.className = 'time-bar-fill';
  tbFill.style.transition = 'none'; tbFill.style.width = '100%';
  requestAnimationFrame(() => requestAnimationFrame(() => {
    tbFill.style.transition = `width ${limit}s linear`;
    tbFill.style.width = '0%';
  }));
  memTimerID = setInterval(() => {
    memSeconds++;
    const remaining = limit - memSeconds;
    const timerEl = document.getElementById('timer-val');
    if (remaining <= 0) {
      clearInterval(memTimerID);
      timerEl.textContent = '0:00';
      timeOutGame(); return;
    }
    timerEl.textContent = Math.floor(remaining/60)+':'+(remaining%60).toString().padStart(2,'0');
    if (remaining <= 15) { timerEl.classList.add('warn'); tbFill.className = 'time-bar-fill warn'; }
  }, 1000);
}
function stopMemTimer() { clearInterval(memTimerID); }

function onMemCardClick(e) {
  const card = e.currentTarget;
  if (memLocked || card.classList.contains('flipped') || card.classList.contains('matched')) return;
  if (!memActive) { memActive = true; startMemTimer(); }
  card.classList.add('flipped');
  playFlip();
  memFlipped.push(card);
  if (memFlipped.length === 2) { memMoves++; document.getElementById('moves-val').textContent = memMoves; checkMemMatch(); }
}

function checkMemMatch() {
  const [a, b] = memFlipped;
  if (a.dataset.emoji === b.dataset.emoji) {
    a.classList.add('matched'); b.classList.add('matched');
    memMatched++; memStreak++;
    document.getElementById('pairs-val').textContent = memMatched+' / '+memTotalPairs;
    memFlipped = [];
    setTimeout(() => playMatch(), 120);
    // 4-in-a-row combo (medium / hard only)
    if (memStreak > 0 && memStreak % 4 === 0 && (chosenDiff === 'medium' || chosenDiff === 'hard')) {
      setTimeout(() => showToast('ğŸ¦‰', T[chosenLang].combo), 250);
    }
    if (memMatched === memTotalPairs) setTimeout(() => showWin('memory', memMoves, memSeconds), 600);
  } else {
    memStreak = 0;
    memLocked = true; playNoMatch();
    a.classList.add('wrong'); b.classList.add('wrong');
    setTimeout(() => {
      a.classList.remove('flipped','wrong'); b.classList.remove('flipped','wrong');
      memFlipped = []; memLocked = false;
    }, 950);
  }
}

// â”€â”€ Memory scoring: speed 60% + efficiency 40% â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function calcMemScore(moves, secs) {
  const limit    = MEM_TIME_LIMIT[chosenDiff];
  const sc       = CFG.scoring.memory;
  const speedPts = sc.speedWeight * Math.max(0, 1 - secs / limit);
  const effPts   = Math.max(0, sc.effWeight - Math.max(0, moves - memTotalPairs) * sc.mistakePenalty);
  return Math.max(50, Math.round(speedPts + effPts));
}
function calcMemStars(moves, secs) {
  const sc = calcMemScore(moves, secs);
  const [t3, t2] = CFG.scoring.starThresholds;
  return sc >= t3 ? 3 : sc >= t2 ? 2 : 1;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MAZE â€” Generation  (recursive backtracker)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function initMaze() {
  mazeSteps = 0; mazeSeconds = 0; mazeActive = false;
  stopMazeTimer();
  document.getElementById('maze-steps-val').textContent = '0';
  const mzLimit = MAZE_TIME_LIMIT[chosenDiff];
  const mzTimerEl = document.getElementById('maze-timer-val');
  mzTimerEl.textContent = Math.floor(mzLimit/60)+':'+(mzLimit%60).toString().padStart(2,'0');
  mzTimerEl.classList.remove('warn');
  const mzFill = document.getElementById('maze-tb-fill');
  mzFill.className = 'time-bar-fill'; mzFill.style.transition = 'none'; mzFill.style.width = '100%';

  const badge = document.getElementById('maze-diff-badge');
  badge.textContent = T[chosenLang].diffBadge[chosenDiff];
  badge.className   = 'diff-badge ' + chosenDiff;

  const n   = MAZE_SIZE[chosenDiff];
  mazeCols  = n; mazeRows = n;
  playerX   = 0; playerY = 0;
  goalX     = n-1; goalY = n-1;

  // Quality thresholds per difficulty
  const minSteps    = Math.floor(n * n * ({ easy:0.35, medium:0.42, hard:0.48 }[chosenDiff]));
  const minDeadEnds = { easy: 8, medium: 18, hard: 32 }[chosenDiff];
  // Junctions = cells with 3+ open sides â€” forces real decision-making at every step
  const minJunctions = { easy: 4, medium: 12, hard: 22 }[chosenDiff];
  // Direction changes in solution path â€” prevents one long easy corridor to goal
  const minTurns     = { easy: 5, medium: 12, hard: 20 }[chosenDiff];
  const inner = Math.floor(n * 0.30);
  const outer = n - inner;
  const minCenter = { easy: 2, medium: 5, hard: 9 }[chosenDiff];

  let attempts = 0;
  do {
    mazeGrid    = generateMaze(n, n);
    mazeOptimal = bfsMaze(0, 0, goalX, goalY);
    attempts++;
    if (attempts > 300) break;  // safety: never freeze the browser
  } while (
    mazeOptimal < minSteps ||
    countDeadEnds(mazeGrid, n, n) < minDeadEnds ||
    countJunctions(mazeGrid, n, n) < minJunctions ||
    countSolutionTurns(getMazeSolutionPath(0, 0, goalX, goalY)) < minTurns ||
    getMazeSolutionPath(0, 0, goalX, goalY).filter(({c,r}) => c>=inner && c<outer && r>=inner && r<outer).length < minCenter
  );

  renderMaze();
}

function restartMaze() { initMaze(); }

function generateMaze(cols, rows) {
  const grid = Array.from({length:rows}, (_,r) =>
    Array.from({length:cols}, (_,c) => ({c, r, walls:{N:true,S:true,E:true,W:true}, visited:false}))
  );
  const getCell = (c,r) => (c<0||c>=cols||r<0||r>=rows) ? null : grid[r][c];
  const DIRS = [{dc:0,dr:-1,d:'N',o:'S'},{dc:0,dr:1,d:'S',o:'N'},{dc:1,dr:0,d:'E',o:'W'},{dc:-1,dr:0,d:'W',o:'E'}];

  // No direction bias â€” pure random branching = maximum junctions and decision points
  const windBias = 0;

  const stack = [grid[0][0]];
  grid[0][0].visited = true;
  let lastDir = null;

  while (stack.length) {
    const cur = stack[stack.length-1];
    const ns  = DIRS.map(({dc,dr,d,o}) => ({nc:cur.c+dc, nr:cur.r+dr, d, o}))
                    .filter(({nc,nr}) => getCell(nc,nr) && !getCell(nc,nr).visited);
    if (!ns.length) { stack.pop(); lastDir = null; continue; }

    let pick;
    const straight = lastDir && ns.find(n => n.d === lastDir);
    if (straight && Math.random() < windBias) {
      pick = straight;  // continue in same direction
    } else {
      pick = ns[0 | Math.random() * ns.length];  // random turn
    }

    lastDir = pick.d;
    cur.walls[pick.d] = false;
    grid[pick.nr][pick.nc].walls[pick.o] = false;
    grid[pick.nr][pick.nc].visited = true;
    stack.push(grid[pick.nr][pick.nc]);
  }
  return grid;
}

// Count junction cells (3+ open sides) â€” more junctions = harder decisions
function countJunctions(grid, cols, rows) {
  let n = 0;
  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++)
      if (['N','S','E','W'].filter(d => !grid[r][c].walls[d]).length >= 3) n++;
  return n;
}

// Count direction changes in the solution path â€” many turns = no obvious straight route
function countSolutionTurns(path) {
  let turns = 0;
  for (let i = 2; i < path.length; i++) {
    const dc1 = path[i-1].c - path[i-2].c, dr1 = path[i-1].r - path[i-2].r;
    const dc2 = path[i].c   - path[i-1].c, dr2 = path[i].r   - path[i-1].r;
    if (dc1 !== dc2 || dr1 !== dr2) turns++;
  }
  return turns;
}

// Count dead-end cells (only 1 opening) â€” higher count = more confusing maze
function countDeadEnds(grid, cols, rows) {
  let n = 0;
  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++)
      if (['N','S','E','W'].filter(d => !grid[r][c].walls[d]).length === 1) n++;
  return n;
}

// BFS for shortest path length
function bfsMaze(sc, sr, ec, er) {
  const visited = Array.from({length:mazeRows}, () => new Uint8Array(mazeCols));
  const q = [{c:sc, r:sr, dist:0}];
  visited[sr][sc] = 1;
  const DIRS = [{d:'N',dc:0,dr:-1},{d:'S',dc:0,dr:1},{d:'E',dc:1,dr:0},{d:'W',dc:-1,dr:0}];
  while (q.length) {
    const {c,r,dist} = q.shift();
    if (c===ec && r===er) return dist;
    for (const {d,dc,dr} of DIRS) {
      const nc=c+dc, nr=r+dr;
      if (nc<0||nc>=mazeCols||nr<0||nr>=mazeRows||visited[nr][nc]||mazeGrid[r][c].walls[d]) continue;
      visited[nr][nc] = 1;
      q.push({c:nc, r:nr, dist:dist+1});
    }
  }
  return 1;
}

// BFS that returns the actual path cells â€” used to validate path goes through center
function getMazeSolutionPath(sc, sr, ec, er) {
  const prev = Array.from({length:mazeRows}, () => new Array(mazeCols).fill(null));
  const q    = [{c:sc, r:sr}];
  prev[sr][sc] = {c:-1, r:-1};
  const DIRS = [{d:'N',dc:0,dr:-1},{d:'S',dc:0,dr:1},{d:'E',dc:1,dr:0},{d:'W',dc:-1,dr:0}];
  while (q.length) {
    const {c,r} = q.shift();
    if (c===ec && r===er) {
      const path = [];
      let cur = {c, r};
      while (cur.c !== -1) { path.push(cur); cur = prev[cur.r][cur.c]; }
      return path;
    }
    for (const {d,dc,dr} of DIRS) {
      const nc=c+dc, nr=r+dr;
      if (nc<0||nc>=mazeCols||nr<0||nr>=mazeRows||prev[nr][nc]||mazeGrid[r][c].walls[d]) continue;
      prev[nr][nc] = {c, r};
      q.push({c:nc, r:nr});
    }
  }
  return [];
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MAZE â€” Rendering
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function renderMaze() {
  const canvas = document.getElementById('maze-canvas');
  const size   = Math.min(window.innerWidth - 44, 420);
  canvas.width = canvas.height = size;
  const ctx    = canvas.getContext('2d');
  const cell   = size / mazeCols;

  ctx.fillStyle = '#150800';
  ctx.fillRect(0, 0, size, size);

  // Walls
  ctx.strokeStyle = '#7A3A14';
  ctx.lineWidth   = Math.max(1.5, cell * 0.1);
  ctx.lineCap     = 'square';

  for (let r=0; r<mazeRows; r++) {
    for (let c=0; c<mazeCols; c++) {
      const x=c*cell, y=r*cell, walls=mazeGrid[r][c].walls;
      ctx.beginPath();
      if (walls.N) { ctx.moveTo(x,y);       ctx.lineTo(x+cell,y);       }
      if (walls.S) { ctx.moveTo(x,y+cell);  ctx.lineTo(x+cell,y+cell);  }
      if (walls.W) { ctx.moveTo(x,y);       ctx.lineTo(x,y+cell);       }
      if (walls.E) { ctx.moveTo(x+cell,y);  ctx.lineTo(x+cell,y+cell);  }
      ctx.stroke();
    }
  }

  const fs = Math.max(16, cell * 0.88);
  const emojiFont = `${fs}px 'Segoe UI Emoji','Apple Color Emoji','Noto Color Emoji',serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Coffee goal â€” green halo circle + emoji
  const gx=goalX*cell, gy=goalY*cell;
  const gcx=gx+cell/2, gcy=gy+cell/2, gr=cell*0.45;
  ctx.save();
  ctx.shadowColor = 'rgba(76,210,80,0.9)';
  ctx.shadowBlur  = cell * 0.6;
  ctx.fillStyle   = 'rgba(76,175,80,0.45)';
  ctx.beginPath(); ctx.arc(gcx, gcy, gr, 0, Math.PI*2); ctx.fill();
  ctx.restore();
  ctx.font = emojiFont;
  ctx.fillText('â˜•', gcx, gcy+1);

  // Owl player â€” gold halo circle + emoji
  const px=playerX*cell, py=playerY*cell;
  const pcx=px+cell/2, pcy=py+cell/2, pr=cell*0.45;
  ctx.save();
  ctx.shadowColor = 'rgba(244,168,64,0.95)';
  ctx.shadowBlur  = cell * 0.7;
  ctx.fillStyle   = 'rgba(244,140,40,0.38)';
  ctx.beginPath(); ctx.arc(pcx, pcy, pr, 0, Math.PI*2); ctx.fill();
  ctx.restore();
  ctx.font = emojiFont;
  ctx.fillText('ğŸ¦‰', pcx, pcy+1);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MAZE â€” Controls
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function dpadPress(btn, dir) {
  btn.classList.add('pressed');
  mazeMove(dir);
}
function dpadRelease(btn) { btn.classList.remove('pressed'); }

document.addEventListener('keydown', e => {
  const mazeOpen     = document.getElementById('maze-screen').style.display === 'block';
  const pacchickOpen = document.getElementById('pacchick-screen').style.display === 'block';
  if (!mazeOpen && !pacchickOpen) return;
  if (mazeOpen) {
    const map = { ArrowUp:'N', ArrowDown:'S', ArrowLeft:'W', ArrowRight:'E', w:'N', s:'S', a:'W', d:'E', W:'N', S:'S', A:'W', D:'E' };
    if (map[e.key]) { e.preventDefault(); mazeMove(map[e.key]); }
  } else {
    const map = { ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right', w:'up', s:'down', a:'left', d:'right', W:'up', S:'down', A:'left', D:'right' };
    if (map[e.key]) { e.preventDefault(); pcDir(map[e.key]); }
  }
});

// Swipe on canvas
let _tx=0, _ty=0;
(function(){
  const c = document.getElementById('maze-canvas');
  c.addEventListener('touchstart', e=>{ _tx=e.touches[0].clientX; _ty=e.touches[0].clientY; },{passive:true});
  c.addEventListener('touchend', e=>{
    const dx=e.changedTouches[0].clientX-_tx, dy=e.changedTouches[0].clientY-_ty;
    if (Math.abs(dx)<12 && Math.abs(dy)<12) return;
    if (Math.abs(dx)>Math.abs(dy)) mazeMove(dx>0?'E':'W'); else mazeMove(dy>0?'S':'N');
  },{passive:true});
})();

function mazeMove(dir) {
  if (document.getElementById('win-screen').classList.contains('show')) return;
  const dmap = {N:{dc:0,dr:-1},S:{dc:0,dr:1},E:{dc:1,dr:0},W:{dc:-1,dr:0}};
  const {dc,dr} = dmap[dir];
  const nx=playerX+dc, ny=playerY+dr;
  if (nx<0||nx>=mazeCols||ny<0||ny>=mazeRows) return;
  if (mazeGrid[playerY][playerX].walls[dir]) return;         // wall blocks

  if (!mazeActive) { mazeActive=true; startMazeTimer(); }
  playerX=nx; playerY=ny;
  mazeSteps++;
  document.getElementById('maze-steps-val').textContent = mazeSteps;
  playFlip();
  renderMaze();

  if (playerX===goalX && playerY===goalY) {
    stopMazeTimer();
    setTimeout(() => showWin('maze', mazeSteps, mazeSeconds), 400);
  }
}

function startMazeTimer() {
  clearInterval(mazeTimerID);
  const limit = MAZE_TIME_LIMIT[chosenDiff];
  const tbFill = document.getElementById('maze-tb-fill');
  tbFill.className = 'time-bar-fill';
  tbFill.style.transition = 'none'; tbFill.style.width = '100%';
  requestAnimationFrame(() => requestAnimationFrame(() => {
    tbFill.style.transition = `width ${limit}s linear`;
    tbFill.style.width = '0%';
  }));
  mazeTimerID = setInterval(() => {
    mazeSeconds++;
    const remaining = limit - mazeSeconds;
    const timerEl = document.getElementById('maze-timer-val');
    if (remaining <= 0) {
      clearInterval(mazeTimerID);
      timerEl.textContent = '0:00';
      timeOutGame(); return;
    }
    timerEl.textContent = Math.floor(remaining/60)+':'+(remaining%60).toString().padStart(2,'0');
    if (remaining <= 15) { timerEl.classList.add('warn'); tbFill.className = 'time-bar-fill warn'; }
  }, 1000);
}
function stopMazeTimer() { clearInterval(mazeTimerID); }

/* â•â• TOAST & TIMEOUT â•â• */
function showToast(icon, text) {
  const t = document.getElementById('combo-toast');
  t.querySelector('.ct-icon').textContent = icon;
  t.querySelector('.ct-text').textContent = text;
  t.classList.remove('show');
  void t.offsetWidth; // force reflow to restart animation
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2200);
}

function timeOutGame() {
  const screenId = currentGame === 'memory' ? 'game-screen' : currentGame === 'maze' ? 'maze-screen' : 'pacchick-screen';
  if (currentGame === 'memory') { stopMemTimer(); clearTimeout(previewTID); memActive = false; }
  else if (currentGame === 'maze') { stopMazeTimer(); mazeActive = false; }
  else { stopPacChick(); }
  showToast('â°', T[chosenLang].timeout);
  setTimeout(() => {
    const el = document.getElementById(screenId);
    el.classList.add('game-fading');
    setTimeout(() => { el.classList.remove('game-fading'); goToHome(); }, 650);
  }, 1300);
}

// â”€â”€ Maze scoring: speed 60% + optimal path 40% â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function calcMazeScore(steps, secs) {
  const limit    = MAZE_TIME_LIMIT[chosenDiff];
  const sc       = CFG.scoring.maze;
  const speedPts = sc.speedWeight * Math.max(0, 1 - secs / limit);
  const effPts   = Math.max(0, sc.effWeight - Math.max(0, steps - mazeOptimal) * sc.extraStepPenalty);
  return Math.max(50, Math.round(speedPts + effPts));
}
function calcMazeStars(steps, secs) {
  const sc = calcMazeScore(steps, secs);
  const [t3, t2] = CFG.scoring.starThresholds;
  return sc >= t3 ? 3 : sc >= t2 ? 2 : 1;
}

window.addEventListener('resize', () => {
  if (mazeGrid.length && document.getElementById('maze-screen').style.display === 'block') renderMaze();
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PAC-CHICK GAME
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const PC_GRID = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
  [1,2,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,2,1],
  [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1],
  [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
  [1,1,1,1,1,0,1,1,1,3,1,3,1,1,1,0,1,1,1,1,1],
  [3,3,3,3,1,0,1,3,3,3,3,3,3,3,1,0,1,3,3,3,3],
  [1,1,1,1,1,0,1,3,1,1,3,1,1,3,1,0,1,1,1,1,1],
  [3,3,3,3,3,0,3,3,1,3,3,3,1,3,3,0,3,3,3,3,3],
  [1,1,1,1,1,0,1,3,1,1,1,1,1,3,1,0,1,1,1,1,1],
  [3,3,3,3,1,0,1,3,3,3,3,3,3,3,1,0,1,3,3,3,3],
  [1,1,1,1,1,0,1,3,1,1,1,1,1,3,1,0,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
  [1,2,0,0,1,0,0,0,0,0,3,0,0,0,0,0,1,0,0,2,1],
  [1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1],
  [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
  [1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];
const PC_COLS = 21, PC_ROWS = 22;
const PC_DVEC     = { right:[1,0], left:[-1,0], up:[0,-1], down:[0,1] };
const PC_OPPOSITE = { right:'left', left:'right', up:'down', down:'up' };
const PC_GHOST_DEFS = [
  { col:10, row:9,  color:'#FF5555', delay:500   },
  { col:10, row:10, color:'#55BBFF', delay:5000  },
  { col:9,  row:10, color:'#FFB8DE', delay:9000  },
  { col:11, row:10, color:'#FFB84D', delay:13000 },
];

// State
let pcPlayer = null, pcGhosts = [], pcPellets, pcPowerPellets;
let pcScore = 0, pcLives = 3, pcSeconds = 0;
let pcActive = false, pcFrightened = false, pcFrightTimer = 0;
let pcRAF = null, pcTimerID_pc = null, pcTileSize = 18;
let pcTotalPellets = 0, pcGameStartTime = 0;

function initPacChick() {
  stopPacChick();
  pcScore = 0; pcLives = 3; pcSeconds = 0;
  pcActive = true; pcFrightened = false; pcFrightTimer = 0;
  pcGameStartTime = Date.now();

  const numGhosts = { easy:2, medium:3, hard:4 }[chosenDiff];
  pcPlayer = { col:10, row:16, fromCol:10, fromRow:16, toCol:10, toRow:16,
               dir:'right', nextDir:'right', t:1, alive:true, respawnTimer:0 };
  pcGhosts = PC_GHOST_DEFS.slice(0, numGhosts).map(g => ({
    col:g.col, row:g.row, fromCol:g.col, fromRow:g.row, toCol:g.col, toRow:g.row,
    homeCol:g.col, homeRow:g.row, dir:'up', t:1,
    color:g.color, delay:g.delay, inHouse:true, frightened:false, respawnTimer:0,
  }));

  pcPellets = new Set(); pcPowerPellets = new Set();
  for (let r = 0; r < PC_ROWS; r++)
    for (let c = 0; c < PC_COLS; c++) {
      if (PC_GRID[r][c] === 0) pcPellets.add(`${c},${r}`);
      if (PC_GRID[r][c] === 2) pcPowerPellets.add(`${c},${r}`);
    }
  pcTotalPellets = pcPellets.size + pcPowerPellets.size;

  // Canvas sizing
  const canvas = document.getElementById('pacchick-canvas');
  const maxW = Math.min(window.innerWidth - 44, 420);
  pcTileSize = Math.floor(maxW / PC_COLS);
  canvas.width  = pcTileSize * PC_COLS;
  canvas.height = pcTileSize * PC_ROWS;

  // UI
  const limit = CFG.timeLimits.pacchick[chosenDiff];
  const timerEl = document.getElementById('pc-timer-val');
  timerEl.textContent = Math.floor(limit/60)+':'+(limit%60).toString().padStart(2,'0');
  timerEl.classList.remove('warn');
  document.getElementById('pc-score-val').textContent = '0';
  pcUpdateLives();
  const badge = document.getElementById('pc-diff-badge');
  badge.textContent = T[chosenLang].diffBadge[chosenDiff];
  badge.className = 'diff-badge ' + chosenDiff;
  const fill = document.getElementById('pc-tb-fill');
  fill.className = 'time-bar-fill'; fill.style.transition = 'none'; fill.style.width = '100%';

  pcTimerID_pc = setInterval(pcTick, 1000);
  pcRAF = requestAnimationFrame(pcLoop);
}

function pcUpdateLives() {
  document.getElementById('pc-lives-val').textContent = 'ğŸ¥'.repeat(Math.max(0, pcLives));
}

function pcTick() {
  if (!pcActive) return;
  pcSeconds++;
  const limit = CFG.timeLimits.pacchick[chosenDiff];
  const rem = limit - pcSeconds;
  const timerEl = document.getElementById('pc-timer-val');
  timerEl.textContent = Math.max(0,Math.floor(rem/60))+':'+(Math.max(0,rem%60)).toString().padStart(2,'0');
  if (rem <= 10) timerEl.classList.add('warn');
  const fill = document.getElementById('pc-tb-fill');
  fill.style.transition = 'width 1s linear';
  fill.style.width = Math.max(0, rem/limit*100) + '%';
  if (rem <= 0) { stopPacChick(); timeOutGame(); }
}

function stopPacChick() {
  pcActive = false;
  cancelAnimationFrame(pcRAF); pcRAF = null;
  clearInterval(pcTimerID_pc); pcTimerID_pc = null;
}
function restartPacChick() { initPacChick(); }
function pcDir(d) { if (pcPlayer) pcPlayer.nextDir = d; }

// â”€â”€ Tile accessibility â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pcCanEnter(c, r, isGhost) {
  if (c < 0 || c >= PC_COLS || r < 0 || r >= PC_ROWS) return false;
  const v = PC_GRID[r][c];
  if (v === 1) return false;
  if (v === 3 && !isGhost) return false;
  return true;
}

// â”€â”€ Tile-based movement with smooth interpolation â”€â”€â”€â”€â”€â”€
function pcMoveEntity(e, speed, chooseDirFn) {
  if (e.t >= 1) {
    e.col = e.toCol; e.row = e.toRow;
    const nd = chooseDirFn(e);
    if (nd) {
      const [dc, dr] = PC_DVEC[nd];
      e.fromCol = e.col; e.fromRow = e.row;
      e.toCol = e.col + dc; e.toRow = e.row + dr;
      e.dir = nd; e.t = 0;
    }
  } else {
    e.t = Math.min(1, e.t + speed);
  }
}

function pcChoosePlayerDir(p) {
  for (const d of [p.nextDir, p.dir]) {
    const [dc, dr] = PC_DVEC[d];
    if (pcCanEnter(p.col + dc, p.row + dr, false)) { p.dir = d; return d; }
  }
  return null;
}

function pcChooseGhostDir(g) {
  const dirs = Object.keys(PC_DVEC);
  const noRev = dirs.filter(d => d !== PC_OPPOSITE[g.dir] && pcCanEnter(g.col+PC_DVEC[d][0], g.row+PC_DVEC[d][1], true));
  const cands = noRev.length ? noRev : dirs.filter(d => pcCanEnter(g.col+PC_DVEC[d][0], g.row+PC_DVEC[d][1], true));
  if (!cands.length) return null;
  if (g.frightened) return cands[Math.floor(Math.random()*cands.length)];
  // Chase: greedy toward player
  let best = cands[0], bestD = Infinity;
  for (const d of cands) {
    const [dc,dr] = PC_DVEC[d];
    const dist = (g.col+dc - pcPlayer.col)**2 + (g.row+dr - pcPlayer.row)**2;
    if (dist < bestD) { bestD = dist; best = d; }
  }
  return best;
}

function pcExitDir(g) {
  // Navigate toward (9,6) â€” first open tile above ghost house
  const tc = 9, tr = 6;
  const dirs = Object.keys(PC_DVEC);
  const cands = dirs.filter(d => pcCanEnter(g.col+PC_DVEC[d][0], g.row+PC_DVEC[d][1], true));
  if (!cands.length) return null;
  let best = cands[0], bestD = Infinity;
  for (const d of cands) {
    const [dc,dr] = PC_DVEC[d];
    const dist = (g.col+dc - tc)**2 + (g.row+dr - tr)**2;
    if (dist < bestD) { bestD = dist; best = d; }
  }
  return best;
}

// â”€â”€ Main loop & update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PC_SPD = { player:0.13, ghost:{easy:0.08, medium:0.10, hard:0.13}, fright:0.055, exit:0.09 };

function pcLoop() {
  pcUpdate();
  pcRender();
  if (pcActive) pcRAF = requestAnimationFrame(pcLoop);
}

function pcUpdate() {
  const now = Date.now();

  // Fright timer
  if (pcFrightened && now - pcFrightTimer > 7000) {
    pcFrightened = false;
    pcGhosts.forEach(g => { g.frightened = false; });
  }

  // Player respawn wait
  if (!pcPlayer.alive) {
    if (now >= pcPlayer.respawnTimer) {
      pcPlayer.alive = true;
      pcPlayer.col = pcPlayer.fromCol = pcPlayer.toCol = 10;
      pcPlayer.row = pcPlayer.fromRow = pcPlayer.toRow = 16;
      pcPlayer.dir = 'right'; pcPlayer.nextDir = 'right'; pcPlayer.t = 1;
      pcGhosts.forEach(g => {
        g.col = g.homeCol; g.row = g.homeRow;
        g.fromCol = g.homeCol; g.fromRow = g.homeRow;
        g.toCol = g.homeCol; g.toRow = g.homeRow;
        g.t = 1; g.inHouse = true; g.frightened = false; g.respawnTimer = 0;
      });
    }
    return;
  }

  // Player move
  pcMoveEntity(pcPlayer, PC_SPD.player, pcChoosePlayerDir);

  // Eat pellets at landed tile
  const key = `${pcPlayer.col},${pcPlayer.row}`;
  if (pcPellets.has(key)) {
    pcPellets.delete(key); pcScore += 10;
    document.getElementById('pc-score-val').textContent = pcScore;
    playFlip();
    if (pcPellets.size + pcPowerPellets.size === 0) {
      stopPacChick();
      setTimeout(() => showWin('pacchick', pcScore, pcSeconds), 400);
      return;
    }
  } else if (pcPowerPellets.has(key)) {
    pcPowerPellets.delete(key); pcScore += 50;
    document.getElementById('pc-score-val').textContent = pcScore;
    pcFrightened = true; pcFrightTimer = now;
    pcGhosts.forEach(g => { if (!g.inHouse && g.respawnTimer === 0) g.frightened = true; });
    playPowerup();
  }

  // Ghost move
  const gSpd = PC_SPD.ghost[chosenDiff];
  for (const g of pcGhosts) {
    if (g.respawnTimer > 0) {
      if (now >= g.respawnTimer) {
        g.respawnTimer = 0; g.frightened = false;
        g.inHouse = true;
        g.col = g.homeCol; g.row = g.homeRow;
        g.fromCol = g.homeCol; g.fromRow = g.homeRow;
        g.toCol = g.homeCol; g.toRow = g.homeRow; g.t = 1;
      }
      continue;
    }
    if (g.inHouse) {
      if (now < pcGameStartTime + g.delay) continue; // still waiting
      pcMoveEntity(g, PC_SPD.exit, pcExitDir);
      if (g.t >= 1 && PC_GRID[g.toRow] && PC_GRID[g.toRow][g.toCol] === 0) g.inHouse = false;
    } else {
      pcMoveEntity(g, g.frightened ? PC_SPD.fright : gSpd, pcChooseGhostDir);
    }
  }

  // Collision detection
  const px = pcPlayer.fromCol + (pcPlayer.toCol - pcPlayer.fromCol) * pcPlayer.t;
  const py = pcPlayer.fromRow + (pcPlayer.toRow - pcPlayer.fromRow) * pcPlayer.t;
  for (const g of pcGhosts) {
    if (g.inHouse || g.respawnTimer > 0) continue;
    const gx = g.fromCol + (g.toCol - g.fromCol) * g.t;
    const gy = g.fromRow + (g.toRow - g.fromRow) * g.t;
    if (Math.abs(px - gx) < 0.72 && Math.abs(py - gy) < 0.72) {
      if (g.frightened) {
        g.frightened = false; g.respawnTimer = now + 4000;
        pcScore += 200;
        document.getElementById('pc-score-val').textContent = pcScore;
        playMatch();
      } else {
        pcLoseLife(); return;
      }
    }
  }
}

function pcLoseLife() {
  pcLives--; pcUpdateLives(); playNoMatch();
  if (pcLives <= 0) { stopPacChick(); timeOutGame(); }
  else { pcPlayer.alive = false; pcPlayer.respawnTimer = Date.now() + 1500; }
}

// â”€â”€ Render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pcRender() {
  const canvas = document.getElementById('pacchick-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const ts = pcTileSize;
  ctx.fillStyle = '#100500';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Walls
  for (let r = 0; r < PC_ROWS; r++) {
    for (let c = 0; c < PC_COLS; c++) {
      if (PC_GRID[r][c] === 1) {
        ctx.fillStyle = '#2a0e00';
        ctx.fillRect(c*ts, r*ts, ts, ts);
        ctx.strokeStyle = '#7A3A14';
        ctx.lineWidth = Math.max(1, ts * 0.1);
        ctx.strokeRect(c*ts + 0.5, r*ts + 0.5, ts-1, ts-1);
      }
    }
  }

  // Pellets
  ctx.fillStyle = '#F4A840';
  for (const k of pcPellets) {
    const [c,r] = k.split(',').map(Number);
    ctx.beginPath();
    ctx.arc(c*ts + ts/2, r*ts + ts/2, ts*0.11, 0, Math.PI*2);
    ctx.fill();
  }

  // Power pellets (blinking every 400ms)
  if (Math.floor(Date.now()/400)%2 === 0) {
    ctx.fillStyle = '#FFD700';
    for (const k of pcPowerPellets) {
      const [c,r] = k.split(',').map(Number);
      ctx.beginPath();
      ctx.arc(c*ts + ts/2, r*ts + ts/2, ts*0.28, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Emoji font for player + frightened ghosts
  const ef = `${Math.max(8, Math.round(ts*0.82))}px serif`;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

  // Ghosts
  for (const g of pcGhosts) {
    if (g.respawnTimer > 0) continue;
    const gx = (g.fromCol + (g.toCol-g.fromCol)*g.t)*ts + ts/2;
    const gy = (g.fromRow + (g.toRow-g.fromRow)*g.t)*ts + ts/2;
    if (g.frightened) {
      ctx.font = ef; ctx.fillText('ğŸ’£', gx, gy);
    } else {
      ctx.fillStyle = g.color;
      ctx.shadowColor = g.color; ctx.shadowBlur = ts*0.5;
      ctx.beginPath(); ctx.arc(gx, gy, ts*0.36, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(gx-ts*0.11, gy-ts*0.1, ts*0.1, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(gx+ts*0.11, gy-ts*0.1, ts*0.1, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#000d';
      ctx.beginPath(); ctx.arc(gx-ts*0.09, gy-ts*0.09, ts*0.055, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(gx+ts*0.13, gy-ts*0.09, ts*0.055, 0, Math.PI*2); ctx.fill();
    }
  }

  // Player
  if (pcPlayer && pcPlayer.alive) {
    const px = (pcPlayer.fromCol + (pcPlayer.toCol-pcPlayer.fromCol)*pcPlayer.t)*ts + ts/2;
    const py = (pcPlayer.fromRow + (pcPlayer.toRow-pcPlayer.fromRow)*pcPlayer.t)*ts + ts/2;
    ctx.font = ef;
    ctx.shadowColor = '#FFD700'; ctx.shadowBlur = ts*0.4;
    ctx.fillText('ğŸ¥', px, py);
    ctx.shadowBlur = 0;
  }
}

// â”€â”€ Pac-Chick scoring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function calcPacChickScore(rawScore, secs) {
  const limit = CFG.timeLimits.pacchick[chosenDiff];
  const sc = CFG.scoring.pacchick;
  const timeBonus = Math.round(sc.speedWeight * Math.max(0, 1 - secs/limit));
  const pelletPts = Math.min(sc.pelletsWeight, rawScore);
  return Math.min(1000, pelletPts + timeBonus);
}
function calcPacChickStars(rawScore, secs) {
  const sc = calcPacChickScore(rawScore, secs);
  const [t3, t2] = CFG.scoring.starThresholds;
  return sc >= t3 ? 3 : sc >= t2 ? 2 : 1;
}

window.addEventListener('resize', () => {
  if (document.getElementById('pacchick-screen').style.display === 'block') {
    const canvas = document.getElementById('pacchick-canvas');
    const maxW = Math.min(window.innerWidth-44, 420);
    pcTileSize = Math.floor(maxW/PC_COLS);
    canvas.width = pcTileSize*PC_COLS; canvas.height = pcTileSize*PC_ROWS;
    pcRender();
  }
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SHARED WIN SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function showWin(game, stat1, secs) {
  if (game === 'memory') stopMemTimer();
  else if (game === 'maze') stopMazeTimer();
  else stopPacChick();
  playWin();

  const score = game==='memory' ? calcMemScore(stat1,secs) : game==='maze' ? calcMazeScore(stat1,secs) : calcPacChickScore(stat1,secs);
  const stars  = game==='memory' ? calcMemStars(stat1,secs) : game==='maze' ? calcMazeStars(stat1,secs) : calcPacChickStars(stat1,secs);

  const t = T[chosenLang];

  // Win screen text (language-aware)
  document.querySelector('.win-title').textContent               = t.winTitle;
  document.getElementById('win-sub').textContent                 = game==='memory' ? t.winSubMem : game==='maze' ? t.winSubMaze : t.winSubPacchick;
  document.querySelector('#win-screen .btn').textContent         = t.playAgain;
  document.querySelector('#win-screen .btn.outline').textContent = t.goHome;
  document.querySelector('.disc-code-label').textContent         = t.codeLabel;
  document.getElementById('ws-label1').textContent               = game==='memory' ? t.lMoves : game==='maze' ? t.lSteps : t.lScore;
  document.getElementById('ws-label-time').textContent           = t.lTime;
  document.getElementById('ws-label-score').textContent          = t.lScore;
  document.getElementById('ws-label-best').textContent           = t.lBest;

  // Stats
  document.getElementById('final-stat1').textContent = stat1;
  document.getElementById('final-time').textContent  = fmtTime(secs);
  document.getElementById('final-score').textContent = score;

  // High score  (keyed per game+difficulty)
  const hsKey = `seelaz_hs_${game}_${chosenDiff}`;
  const prev   = parseInt(localStorage.getItem(hsKey)||'0');
  const isNew  = score > prev;
  if (isNew) localStorage.setItem(hsKey, score);
  document.getElementById('hs-val').textContent = Math.max(score,prev);
  document.getElementById('new-best-badge').textContent = t.newBest;
  document.getElementById('new-best-badge').classList.toggle('show', isNew);

  // Stars
  const row = document.getElementById('stars-row');
  row.innerHTML = '';
  for (let i=0;i<3;i++){
    const sp=document.createElement('span');
    sp.className='star'; sp.textContent=i<stars?'â­':'â˜†';
    sp.style.animationDelay=i*0.18+'s';
    row.appendChild(sp);
  }

  // Discount â€” rates from CFG, code generated per win
  const banner  = document.getElementById('discount-banner');
  const discPct = CFG.discount[game][chosenDiff];
  if (stars === 3 && discPct > 0) {
    const code = genDiscountCode(game, chosenDiff, discPct);
    const pctAr = discPct === 5 ? 'Ù¥Ùª' : discPct === 10 ? 'Ù¡Ù Ùª' : discPct+'Ùª';
    const isAr  = chosenLang === 'ar';
    document.getElementById('discount-pct').textContent = isAr
      ? `ğŸ Ø®ØµÙ… ${pctAr} â€” ${discPct}% OFF`
      : `ğŸ ${discPct}% OFF`;
    document.getElementById('discount-text-ar').style.display = isAr ? '' : 'none';
    document.getElementById('discount-text-en').style.display = isAr ? 'none' : '';
    if (isAr) document.getElementById('discount-text-ar').textContent = `Ù‚ÙˆÙ„ Ù„Ù„Ø¨Ø§Ø±Ø³ØªØ§ Ø§Ù„ÙƒÙˆØ¯ Ø¯Ù‡ ÙˆØ§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø®ØµÙ… ${pctAr} Ø¹Ù„Ù‰ Ø£ÙˆØ±Ø¯Ø±Ùƒ! ğŸ‰`;
    else      document.getElementById('discount-text-en').textContent = `Tell the barista this code to get ${discPct}% off Â· ${CFG.website}`;
    document.getElementById('disc-code').textContent = code;
    banner.classList.add('show');
  } else {
    banner.classList.remove('show');
  }

  document.getElementById('win-screen').classList.add('show');
  launchConfetti();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   AUDIO  (Web Audio API â€” no external files)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let _actx = null;
function _ctx() { if(!_actx) _actx=new(window.AudioContext||window.webkitAudioContext)(); return _actx; }
function _beep(freq,type,vol,dur,t0) {
  if(muted)return;
  const ctx=_ctx(),t=t0??ctx.currentTime;
  const osc=ctx.createOscillator(),g=ctx.createGain();
  osc.connect(g); g.connect(ctx.destination);
  osc.type=type||'sine'; osc.frequency.value=freq;
  g.gain.setValueAtTime(vol,t); g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
  osc.start(t); osc.stop(t+dur+0.01);
}
function playFlip() {
  if(muted)return; const ctx=_ctx(),t=ctx.currentTime;
  const osc=ctx.createOscillator(),g=ctx.createGain();
  osc.connect(g); g.connect(ctx.destination);
  osc.frequency.setValueAtTime(900,t); osc.frequency.exponentialRampToValueAtTime(450,t+0.09);
  g.gain.setValueAtTime(0.12,t); g.gain.exponentialRampToValueAtTime(0.0001,t+0.1);
  osc.start(t); osc.stop(t+0.11);
}
function playMatch()   { [523,659,784].forEach((f,i)=>_beep(f,'sine',0.18,0.28,_ctx().currentTime+i*0.13)); }
function playNoMatch() { const t=_ctx().currentTime; _beep(200,'sawtooth',0.15,0.18,t); _beep(150,'sawtooth',0.1,0.18,t+0.1); }
function playWin()     { [523,659,784,1047].forEach((f,i)=>_beep(f,'sine',0.22,0.45,_ctx().currentTime+i*0.2)); }
function playPowerup() { if(muted)return; const t=_ctx().currentTime; [300,500,800].forEach((f,i)=>_beep(f,'square',0.14,0.12,t+i*0.09)); }
function toggleMute()  { muted=!muted; document.getElementById('mute-btn').textContent=muted?'ğŸ”‡':'ğŸ”Š'; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONFETTI
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function launchConfetti() {
  const cols=['#E8843E','#F4A840','#C9682A','#FDF0DC','#8B4E1A','#fff','#f9c74f'];
  for(let i=0;i<90;i++){
    const d=document.createElement('div'); d.className='confetti-dot';
    d.style.cssText=`left:${Math.random()*100}vw;background:${cols[0|Math.random()*cols.length]};animation-duration:${1.8+Math.random()*2.5}s;animation-delay:${Math.random()*1.4}s;width:${7+Math.random()*9}px;height:${7+Math.random()*9}px;transform:rotate(${Math.random()*360}deg);`;
    document.body.appendChild(d);
    d.addEventListener('animationend',()=>d.remove());
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   UTILS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function fmtTime(s) { return Math.floor(s/60)+':'+(s%60).toString().padStart(2,'0'); }

/* â”€â”€ Discount code generator â”€â”€ */
function genDiscountCode(game, diff, pct) {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let rnd = '';
  for (let i = 0; i < 4; i++) rnd += chars[Math.floor(Math.random() * chars.length)];
  const tier = diff === 'medium' ? 'M' : diff === 'hard' ? 'H' : 'E';
  return `${CFG.codePrefix}-${tier}${pct}-${rnd}`;
}

document.addEventListener('DOMContentLoaded', renderConfig);

/* â”€â”€ Populate HTML from CFG on load â”€â”€ */
function renderConfig() {
  document.title = `ğŸ¦‰ ${CFG.brand} Games`;
  document.querySelector('.home-brand').innerHTML = `${CFG.brand} <span>Games</span>`;
  ['memory','maze','pacchick'].forEach(g => {
    const c = document.getElementById('card-'+g);
    if (c) c.querySelector('.gc-icon').textContent = CFG.games[g].icon;
  });
  applyLang();
}

function shuffle(arr) {
  const a=[...arr];
  for(let i=a.length-1;i>0;i--){const j=0|Math.random()*(i+1);[a[i],a[j]]=[a[j],a[i]];}
  return a;
}
</script>
</body>
</html>
